-- we won't allow pattern matching like haskell (in functions) cause that shit dumb lmao
-- fib ~ Int -> Int

-- setting a value

myNum =: 3

myNum ~ Int
myNum =: 3

myNum =: (3 ~ Int) -- inline type signatures must be wrapped in parentheses

myNum ~ (Integral a) => a
myNum =: 3

myNum =: (3 ~ (Integral a) => a)


-- function application
myNum =: 1 + 2
mynum =: 3 - 1

mynum =: -1
mynum =: 1.negate

myNum =: 2.pow(4)


-- defining a function "add-one" that takes a parameter "a" - no signature. Zoda will use type inference to give `a` the trait `Addable`
a.add-one =: a + 1
 
-- defining a function with a signature
add-one ~ Int -> Int
a.add-one =: a + 1

add ~ Int -> Int -> Int
a.add3(b) =: a + b

add3 ~ Int -> Int -> Int -> Int
a.add(b, c) =: a + b + c


-- you can chain functions using `.`. this is useful for "pipelines"
my-value = 3.f.g.h -- take 3, then apply f, then apply g, then apply h
my-value = 3.add(4).subtract(1).times(4).negate.divide(2).absolute-value


-- if you want to, you can curry a function by leaving a `-` in the place of an argument.
i.under3 =: i.(3.divide(_))
-- you can also apply none of the arguments of a function just by not doing anything with it at all
my-val =: my-list.map(add-one)


-- with the x.f(z) syntax, you probably want to make function names read nicely
3.max(4)        -- bad
3.lower-bound(4) -- good


-- any time after a `:`, you should indent if you choose to make a newline
my-val =:
    4


-- if expressions. uses indentation for alignment
a.lower-bound(b) =: 
    if a > b  
        then: a
        else: b

-- these are expressions so you may use them however you like. uses indentation for nesting
a.lower-bound-times(b, x) =: 
    x * if a > b: 
        then a
        else b


-- for any token that ends in a `:`, followed immediately by another bit of syntax that ends with a `:`, the first can and should be left off. the only exception is `=:`.
my-val =: do:
    -- blah blah
my-val =: if 2==2 then:
            True
        else if 3==3 then:
            True
        else do:
            pure False


-- lists
my-list =: [1,2,3,4]
my-list =: 1 :: [2,3,4]   -- [1,2,3,4]
-- These aren't lists specifically, as they can be overloaded so `[1,2,3]` can represent a list, a vector, an array, etc.
-- Also available are Iterators, which are like lists but lazy and useful for iterating over a range of values.
my-iterator =: [1..10]
my-iterator =: [10,20..100]
-- Since they're lazy, they're useful for functions like the following:
n.factorial =: [1..n].product
-- If iterators were not lazy, this would require a O(n) space. Since they are, it requires O(1) space. 
-- list slicing is supported and similar to python's
-- [1,2,3,4,5].get(<1:4>) == Just [2,3,4]
-- List slicing doesn't just work with lists, it works with anything that has the `Slicable` trait
-- This includes Iterators, Vectors, Strings, etc.
-- We have list comprehensions too. Of course, they're not specific to lists. They can actually be used with any Monad, and has an additional `then` and `then by` feature.
myList =: [ (x, y) | x <- xs,
                     y <- ys,
                     then reverse ]



-- higher order functions
x.add-one =: x + 1
my-list =: [1,2,3,4,5].map(add-one)
my-list =: [1,2,3,4,5].map(_.add(1))



-- lambdas
x.add-one =: x.(\x -> x + 1)
-- is equivalent to...
x.add-one =: x + 1

-- the reason that using currying to define these is not allowed is that the names of the arguments is often very helpful for documentation purposes


-- the value-passing operator
-- not really a language feature, just a built-in operator. simply passes a value to a function, left associative
my-val =: add-one <| 3
my-val =: _.add-one <| 3
my-val =: 3.add(_) <| 1
my-val =: 4

-- do notation
a.print-value-cool =:
    do:
        putString("=============")
        print(a)
        putString("=============")

-- desugars to...
a.print-value-cool =:
    do:
        putString("=============") >>= \- ->
        print(a)                 >>= \- ->
        putString("=============") >>= \- ->

-- where statements. valid for functions as well as values. 
my-val =: 
    i + j
    where:
        i =: 3
        j =: 4


-- inline test statements. valid for functions as well as values
-- these are automatically run at compile time, and only rerun if the function or its dependencies change.
a.add-one =: a + 1
    test:
        "can add one to two".test(
            (2.add-one).should-be(3)
        )

-- the "test" section is just a single value - to contain `should-be`s in one test, use do notation.
a.add-one =: a + 1
    test:
        "can add one to positive values".test(_) <| do:
            (2.add-one).should-be(3)
            (3.add-one).should-be(4)

-- and to contain multiple tests, use do notation again
a.add-one =: a + 1
    test do:
        "can add one to positive values".test(_) <| do:
            (2.add-one).should-be(3)
            (3.add-one).should-be(4)
        "can add one to negative values".test(_) <| do:
            (-2.add-one).should-be(-1)
            (-3.add-one).should-be(-2)

-- if you know you haven't implemented the functionality for a test yet, just make it pending
a.incrementAbsoluteValue =: a + 1
    test do:
        "can increment to positive values".test(_) <| do:
            2.add-one.should-be(3)
        "can increment to positive values".test(_) <| do:
            -2.add-one.should-be(-3).pending


-- match
a.luckyNumber7 =: match a:
    7 -> putString("Lucky number 7!")
    _ -> putString("sorry, you are a loser")
l.head =: match l:
    x::_ -> x.Just
    _    -> nothing 
-- all pattern matches must be complete to perform an optimized build - optimized Zoda builds have no runtime errors 


-- inline docs 
-- Seperated into "short-doc" and "long-doc". The short-doc should be very short, and has access to the actual values that are passed to the function (in this case, x and y). 
-- The short-doc is intended to be shown when the cursor is over the function. So if you hover the cursor over `2.add(3)`, you would see `Adds 2 and 3 -> 5`.
-- The long-doc can be as long as you want. It is intended to be shown on documentation pages and should give an in-depth explanation with examples of how it should be used.
-- These examples are also tested at compile time. 
-- Comments with `--` are allowed inside short-docs and long-docs, and will not be included in the output.
x.add(y) =: 
    sum
    where:
        sum = x + y

    test do:
        "can add positive values".test(_) <| do:
            2.add(2).should-be(4)
            3.add(5).should-be(8)

    short-doc: Adds `x` and `y`  
    long-doc:
        Essentially just a wrapper for the `+` operator.
        It works on any values that have the an `Addable` instance, so it can be used anywhere you'd like to add two values together
        
        >> 3.add(5)
        -> 8

        Negative numbers can be added as well.   -- do we need to say this? this seems kind of obvious.

        >> 3.add(-5)
        -> -2

        One use might be to compute a new bank account balance after some money is deposited:

        >> oldBalance =: 300
        >> amountToAdd =: 10
        >> newBalance =: oldBalance.add(amountToAdd)
        >> newBalance
        -> 310

        Although since this function is just a wrapper for `+` there's little reason to use it unless you need currying. 

        >> [1,2,3].map(_.add(3)) 
        -> [4,5,6]

        Since Tuples do not have an `Addable` instance, they cannot be added with this function

        >>error (3,4).add((5,6))

-- Supported editors will have the long-doc collapsed by default, because otherwise it takes quite a bit of space which will probably not always be that helpful. 
-- The long-doc requires two newlines for a linebreak to be present in the output, except in code examples. This makes it possible to set the max line width to whatever 
-- you want within the long-doc and the formatter will adjust it for you.


-- Strings and Chars 
-- We use the same approach to handling Strings that Rust does. To borrow from their documentation:
-- A String is a sequence of Unicode scalar values encoded as a stream of UTF-8 bytes. 
-- All Strings are guaranteed to be a valid encoding of UTF-8 sequences. 
-- Additionally, unlike some languages, Strings are not null-terminated and can contain null bytes. 
-- Strings are allowed to span multiple lines, and are indentation-sensitive 
-- They can also contain inline expressions with { expr } and {s expr }. 
my-val =: 3
my-string =: "My value is: { my-val }" -- my-val.repr is automatically called. x.repr is a function that expresses a value as a String, in a way that should be developer-friendly.
my-string =: "3 + 3 is { 3 + 3 }"
my-string =: "My name is {s "E. Cummings".toLowercase }" -- with `{s expr }`, .repr is not automatically called. For this reason the expression is expected to return a String.
my-string =: "Line 1 
              Line 2" -- equivalent to "Line 1\nLine2"
-- String literals are escaped with a backslash
my-string =: "\"What is it?\" she asked."


-- recursion
-- Zoda does not allow unrestricted recursion. The reason is that unrestricted recursion makes it easy to create a stack explosion:
x.fib =: match x: 
    0 -> 1 
    1 -> 1 
    x -> (x - 1).fib + (x - 2).fib
-- This is bad because `100000.fib` will result in a stack overflow, which is a form of runtime exception. Since Zoda attempts to make runtime exceptions very rare,
-- we need a way to prevent this. There is a way to do recursion without running the risk of a stack overflow - if the recursive call is returned immediately,
-- its very simple for the compiler to unroll it into a loop which will not result in unbounded growth of the stack. 
x.fib =: internalFib x 0 1 
    where counter.internalFib(y,z) =: match counter:
        0       -> z
        counter -> (counter - 1).internalFib(z, y+z)
-- so, we can prevent unbounded growth of the stack by disallowing all recursion that is not tail recursion. But, this is annoying because it means recursive calls are 
-- "special". I think this would be easier to teach to people if we used a special keyword for tail calls. I'm thinking `recurse`.
x.fib =: internalFib x 0 1 
    where counter.internalFib(y,z) =: match counter:
        0       -> z
        counter -> (counter - 1).recuse(z, y+z)
-- so `recurse` is a special function that calls the function it's used in with the same parameters, and the compiler will not let you do anything to a the output of 
-- the `recurse` function. The recurse function is the only situation where recursion is possible - all other functions form a DAG of their dependencies. 
-- The one exception to the "you can't do anything to the output of the `recurse` function" rule is functions with the trait `Chainable`.
-- This doesn't blow up the stack because the `Chainable` trait includes instructions on how to compute an intermediate value. `+`, `*` and `::` are examples of Chainable.
x.factorial =: x * (x-1).recurse
l.filter(f) =: match l:
    []      -> []
    x :: xs -> if (f x) then: 
                   x :: xs.recurse(f)
               else:
                   xs.recurse(f)
                   
-- decorators
-- Functions can have decorators which serve to provide extra information to the compiler.
-- The only one I have any ideas for is `always-terminates`, which says about a function exactly what it says on the tin.
x.addOne =: x + 1 
    info: always-terminates
-- Although I expect `always-terminates` to not be that useful... if a function doesn't call `recurse` and only calls functions marked as 
-- `always-terminates`, then I think it should always terminate.
-- For higher-order functions, `always-terminates` is not available but `always-terminates-if-input-functions-terminate` is.  


-- unwrap
-- the Zoda compiler will do some tricks to attempt to deduce information about the 
-- values passed to various functions and how that relates to their output.
-- For example:
divided-by ~ Float -> Float -> Float.Maybe
numerator.divided-by(denominator) =: match denominator:
    0 -> Nothing
    denominator -> (numerator / denominator).Just

-- Now, we might want to write a `divided-by-3` function, and reuse `divided-by`. But we have an issue! `divided-by-3` will always work, but 
-- if we just plug it into `divided-by`, our function will end up returning `Float.Maybe`, instead of `Float`
-- To solve this, we add a new magical function - unwrap. 
x.divided-by-3 =: (x.divided-by(3)).unwrap
-- unwrap converts a value from a `Maybe a` (actualy, any value with the `Unwrappable` trait) to an `a` *if* the compiler can prove that it will 
-- always actually have a corresponding value. In this case, it can see the call to `divided-by` will only return `Nothing` if the `denominator`
-- is `0`. Since we know at compile time the denominator is `3`, the `unwrap` function can automatically unwrap the `Just`. 
